{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { RequestMethod } from \"../RequestMethod\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { cloneRequestWithNewUrl, setRequestHeader } from \"./MiddlewareUtil\";\nimport { RedirectHandlerOptions } from \"./options/RedirectHandlerOptions\";\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\n/**\r\n * @class\r\n * Class\r\n * @implements Middleware\r\n * Class representing RedirectHandler\r\n */\n\nexport class RedirectHandler {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * To create an instance of RedirectHandler\r\n   * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance\r\n   * @returns An instance of RedirectHandler\r\n   */\n  constructor(options = new RedirectHandlerOptions()) {\n    this.options = options;\n  }\n  /**\r\n   * @private\r\n   * To check whether the response has the redirect status code or not\r\n   * @param {Response} response - The response object\r\n   * @returns A boolean representing whether the response contains the redirect status code or not\r\n   */\n\n\n  isRedirect(response) {\n    return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;\n  }\n  /**\r\n   * @private\r\n   * To check whether the response has location header or not\r\n   * @param {Response} response - The response object\r\n   * @returns A boolean representing the whether the response has location header or not\r\n   */\n\n\n  hasLocationHeader(response) {\n    return response.headers.has(RedirectHandler.LOCATION_HEADER);\n  }\n  /**\r\n   * @private\r\n   * To get the redirect url from location header in response object\r\n   * @param {Response} response - The response object\r\n   * @returns A redirect url from location header\r\n   */\n\n\n  getLocationHeader(response) {\n    return response.headers.get(RedirectHandler.LOCATION_HEADER);\n  }\n  /**\r\n   * @private\r\n   * To check whether the given url is a relative url or not\r\n   * @param {string} url - The url string value\r\n   * @returns A boolean representing whether the given url is a relative url or not\r\n   */\n\n\n  isRelativeURL(url) {\n    return url.indexOf(\"://\") === -1;\n  }\n  /**\r\n   * @private\r\n   * To check whether the authorization header in the request should be dropped for consequent redirected requests\r\n   * @param {string} requestUrl - The request url value\r\n   * @param {string} redirectUrl - The redirect url value\r\n   * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests\r\n   */\n\n\n  shouldDropAuthorizationHeader(requestUrl, redirectUrl) {\n    const schemeHostRegex = /^[A-Za-z].+?:\\/\\/.+?(?=\\/|$)/;\n    const requestMatches = schemeHostRegex.exec(requestUrl);\n    let requestAuthority;\n    let redirectAuthority;\n\n    if (requestMatches !== null) {\n      requestAuthority = requestMatches[0];\n    }\n\n    const redirectMatches = schemeHostRegex.exec(redirectUrl);\n\n    if (redirectMatches !== null) {\n      redirectAuthority = redirectMatches[0];\n    }\n\n    return typeof requestAuthority !== \"undefined\" && typeof redirectAuthority !== \"undefined\" && requestAuthority !== redirectAuthority;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To update a request url with the redirect url\r\n   * @param {string} redirectUrl - The redirect url value\r\n   * @param {Context} context - The context object value\r\n   * @returns Nothing\r\n   */\n\n\n  updateRequestUrl(redirectUrl, context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      context.request = context.request instanceof Request ? yield cloneRequestWithNewUrl(redirectUrl, context.request) : redirectUrl;\n    });\n  }\n  /**\r\n   * @private\r\n   * To get the options for execution of the middleware\r\n   * @param {Context} context - The context object\r\n   * @returns A options for middleware execution\r\n   */\n\n\n  getOptions(context) {\n    let options;\n\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(this.options.constructor.name);\n    }\n\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new RedirectHandlerOptions(), this.options);\n    }\n\n    return options;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To execute the next middleware and to handle in case of redirect response returned by the server\r\n   * @param {Context} context - The context object\r\n   * @param {number} redirectCount - The redirect count value\r\n   * @param {RedirectHandlerOptions} options - The redirect handler options instance\r\n   * @returns A promise that resolves to nothing\r\n   */\n\n\n  executeWithRedirect(context, redirectCount, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.nextMiddleware.execute(context);\n        const response = context.response;\n\n        if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {\n          ++redirectCount;\n\n          if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {\n            context.options.method = RequestMethod.GET;\n            delete context.options.body;\n          } else {\n            const redirectUrl = this.getLocationHeader(response);\n\n            if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {\n              setRequestHeader(context.request, context.options, RedirectHandler.AUTHORIZATION_HEADER, undefined);\n            }\n\n            yield this.updateRequestUrl(redirectUrl, context);\n          }\n\n          yield this.executeWithRedirect(context, redirectCount, options);\n        } else {\n          return;\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * To execute the current middleware\r\n   * @param {Context} context - The context object of the request\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  execute(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const redirectCount = 0;\n        const options = this.getOptions(context);\n        context.options.redirect = RedirectHandler.MANUAL_REDIRECT;\n        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);\n        return yield this.executeWithRedirect(context, redirectCount, options);\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * To set the next middleware in the chain\r\n   * @param {Middleware} next - The middleware instance\r\n   * @returns Nothing\r\n   */\n\n\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n\n}\n/**\r\n * @private\r\n * @static\r\n * A member holding the array of redirect status codes\r\n */\n\nRedirectHandler.REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];\n/**\r\n * @private\r\n * @static\r\n * A member holding SeeOther status code\r\n */\n\nRedirectHandler.STATUS_CODE_SEE_OTHER = 303;\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of the location header\r\n */\n\nRedirectHandler.LOCATION_HEADER = \"Location\";\n/**\r\n * @private\r\n * @static\r\n * A member representing the authorization header name\r\n */\n\nRedirectHandler.AUTHORIZATION_HEADER = \"Authorization\";\n/**\r\n * @private\r\n * @static\r\n * A member holding the manual redirect value\r\n */\n\nRedirectHandler.MANUAL_REDIRECT = \"manual\";","map":null,"metadata":{},"sourceType":"module"}