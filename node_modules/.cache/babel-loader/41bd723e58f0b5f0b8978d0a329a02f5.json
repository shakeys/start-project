{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { RequestMethod } from \"../RequestMethod\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { getRequestHeader, setRequestHeader } from \"./MiddlewareUtil\";\nimport { RetryHandlerOptions } from \"./options/RetryHandlerOptions\";\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\n/**\r\n * @class\r\n * @implements Middleware\r\n * Class for RetryHandler\r\n */\n\nexport class RetryHandler {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * To create an instance of RetryHandler\r\n   * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value\r\n   * @returns An instance of RetryHandler\r\n   */\n  constructor(options = new RetryHandlerOptions()) {\n    this.options = options;\n  }\n  /**\r\n   *\r\n   * @private\r\n   * To check whether the response has the retry status code\r\n   * @param {Response} response - The response object\r\n   * @returns Whether the response has retry status code or not\r\n   */\n\n\n  isRetry(response) {\n    return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;\n  }\n  /**\r\n   * @private\r\n   * To check whether the payload is buffered or not\r\n   * @param {RequestInfo} request - The url string or the request object value\r\n   * @param {FetchOptions} options - The options of a request\r\n   * @returns Whether the payload is buffered or not\r\n   */\n\n\n  isBuffered(request, options) {\n    const method = request instanceof Request ? request.method : options.method;\n    const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;\n\n    if (isPutPatchOrPost) {\n      const isStream = getRequestHeader(request, options, \"Content-Type\") === \"application/octet-stream\";\n\n      if (isStream) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * @private\r\n   * To get the delay for a retry\r\n   * @param {Response} response - The response object\r\n   * @param {number} retryAttempts - The current attempt count\r\n   * @param {number} delay - The delay value in seconds\r\n   * @returns A delay for a retry\r\n   */\n\n\n  getDelay(response, retryAttempts, delay) {\n    const getRandomness = () => Number(Math.random().toFixed(3));\n\n    const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;\n    let newDelay;\n\n    if (retryAfter !== null) {\n      // tslint:disable: prefer-conditional-expression\n      if (Number.isNaN(Number(retryAfter))) {\n        newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);\n      } else {\n        newDelay = Number(retryAfter);\n      } // tslint:enable: prefer-conditional-expression\n\n    } else {\n      // Adding randomness to avoid retrying at a same\n      newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();\n    }\n\n    return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());\n  }\n  /**\r\n   * @private\r\n   * To get an exponential back off value\r\n   * @param {number} attempts - The current attempt count\r\n   * @returns An exponential back off value\r\n   */\n\n\n  getExponentialBackOffTime(attempts) {\n    return Math.round(1 / 2 * (Math.pow(2, attempts) - 1));\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To add delay for the execution\r\n   * @param {number} delaySeconds - The delay value in seconds\r\n   * @returns Nothing\r\n   */\n\n\n  sleep(delaySeconds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const delayMilliseconds = delaySeconds * 1000;\n      return new Promise(resolve => setTimeout(resolve, delayMilliseconds));\n    });\n  }\n\n  getOptions(context) {\n    let options;\n\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(this.options.constructor.name);\n    }\n\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new RetryHandlerOptions(), this.options);\n    }\n\n    return options;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To execute the middleware with retries\r\n   * @param {Context} context - The context object\r\n   * @param {number} retryAttempts - The current attempt count\r\n   * @param {RetryHandlerOptions} options - The retry middleware options instance\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  executeWithRetry(context, retryAttempts, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.nextMiddleware.execute(context);\n\n        if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {\n          ++retryAttempts;\n          setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());\n          const delay = this.getDelay(context.response, retryAttempts, options.delay);\n          yield this.sleep(delay);\n          return yield this.executeWithRetry(context, retryAttempts, options);\n        } else {\n          return;\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * To execute the current middleware\r\n   * @param {Context} context - The context object of the request\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  execute(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const retryAttempts = 0;\n        const options = this.getOptions(context);\n        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);\n        return yield this.executeWithRetry(context, retryAttempts, options);\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * To set the next middleware in the chain\r\n   * @param {Middleware} next - The middleware instance\r\n   * @returns Nothing\r\n   */\n\n\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n\n}\n/**\r\n * @private\r\n * @static\r\n * A list of status codes that needs to be retried\r\n */\n\nRetryHandler.RETRY_STATUS_CODES = [429, 503, 504];\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of retry attempt header\r\n */\n\nRetryHandler.RETRY_ATTEMPT_HEADER = \"Retry-Attempt\";\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of retry after header\r\n */\n\nRetryHandler.RETRY_AFTER_HEADER = \"Retry-After\";","map":null,"metadata":{},"sourceType":"module"}