{"ast":null,"code":"import DefaultEvent from \"./DefaultEvent\"; // for use in cache events\n\nvar MSAL_CACHE_EVENT_VALUE_PREFIX = \"msal.token\";\nvar MSAL_CACHE_EVENT_NAME = \"msal.cache_event\";\n\nvar createEventKey = function (event) {\n  return event.telemetryCorrelationId + \"-\" + event.eventId + \"-\" + event.eventName;\n};\n\nvar TelemetryManager =\n/** @class */\nfunction () {\n  function TelemetryManager(config, telemetryEmitter) {\n    // correlation Id to list of events\n    this.completedEvents = {}; // event key to event\n\n    this.inProgressEvents = {}; // correlation id to map of eventname to count\n\n    this.eventCountByCorrelationId = {}; //Implement after API EVENT\n\n    this.onlySendFailureTelemetry = false; // TODO THROW if bad options\n\n    this.telemetryPlatform = config.platform;\n    this.clientId = config.clientId;\n    this.onlySendFailureTelemetry = config.onlySendFailureTelemetry; // TODO, when i get to wiring this through, think about what it means if\n    // a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\n    // optional?\n\n    this.telemetryEmitter = telemetryEmitter;\n  }\n\n  TelemetryManager.prototype.startEvent = function (event) {\n    if (!this.telemetryEmitter) {\n      return;\n    }\n\n    var eventKey = createEventKey(event);\n    this.inProgressEvents[eventKey] = event;\n  };\n\n  TelemetryManager.prototype.stopEvent = function (event) {\n    var eventKey = createEventKey(event);\n\n    if (!this.telemetryEmitter || !this.inProgressEvents[eventKey]) {\n      return;\n    }\n\n    event.stop();\n    this.incrementEventCount(event);\n    var completedEvents = this.completedEvents[event.telemetryCorrelationId];\n    this.completedEvents[event.telemetryCorrelationId] = (completedEvents || []).concat([event]);\n    delete this.inProgressEvents[eventKey];\n  };\n\n  TelemetryManager.prototype.flush = function (correlationId) {\n    var _this = this; // If there is only unfinished events should this still return them?\n\n\n    if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\n      return;\n    }\n\n    var orphanedEvents = this.getOrphanedEvents(correlationId);\n    orphanedEvents.forEach(function (event) {\n      return _this.incrementEventCount(event);\n    });\n    var eventsToFlush = this.completedEvents[correlationId].concat(orphanedEvents);\n    delete this.completedEvents[correlationId];\n    var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];\n    delete this.eventCountByCorrelationId[correlationId]; // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\n\n    if (!eventsToFlush || !eventsToFlush.length) {\n      return;\n    }\n\n    var defaultEvent = new DefaultEvent(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);\n    var eventsWithDefaultEvent = eventsToFlush.concat([defaultEvent]);\n    this.telemetryEmitter(eventsWithDefaultEvent.map(function (e) {\n      return e.get();\n    }));\n  };\n\n  TelemetryManager.prototype.incrementEventCount = function (event) {\n    var _a; // TODO, name cache event different?\n    // if type is cache event, change name\n\n\n    var eventName = event.eventName;\n    var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\n\n    if (!eventCount) {\n      this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a = {}, _a[eventName] = 1, _a);\n    } else {\n      eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\n    }\n  };\n\n  TelemetryManager.prototype.getOrphanedEvents = function (correlationId) {\n    var _this = this;\n\n    return Object.keys(this.inProgressEvents).reduce(function (memo, eventKey) {\n      if (eventKey.indexOf(correlationId) !== -1) {\n        var event_1 = _this.inProgressEvents[eventKey];\n        delete _this.inProgressEvents[eventKey];\n        return memo.concat([event_1]);\n      }\n\n      return memo;\n    }, []);\n  };\n\n  return TelemetryManager;\n}();\n\nexport default TelemetryManager;","map":null,"metadata":{},"sourceType":"module"}