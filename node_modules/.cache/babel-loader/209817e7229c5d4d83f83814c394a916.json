{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Range } from \"../Range\";\n/**\r\n * @class\r\n * Class representing LargeFileUploadTask\r\n */\n\nexport class LargeFileUploadTask {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * Constructs a LargeFileUploadTask\r\n   * @param {Client} client - The GraphClient instance\r\n   * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\r\n   * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\r\n   * @param {LargeFileUploadTaskOptions} options - The upload task options\r\n   * @returns An instance of LargeFileUploadTask\r\n   */\n  constructor(client, file, uploadSession, options = {}) {\n    /**\r\n     * @private\r\n     * Default value for the rangeSize\r\n     */\n    this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;\n    this.client = client;\n    this.file = file;\n\n    if (options.rangeSize === undefined) {\n      options.rangeSize = this.DEFAULT_FILE_SIZE;\n    }\n\n    this.options = options;\n    this.uploadSession = uploadSession;\n    this.nextRange = new Range(0, this.options.rangeSize - 1);\n  }\n  /**\r\n   * @public\r\n   * @static\r\n   * @async\r\n   * Makes request to the server to create an upload session\r\n   * @param {Client} client - The GraphClient instance\r\n   * @param {any} payload - The payload that needs to be sent\r\n   * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent\r\n   * @returns The promise that resolves to LargeFileUploadSession\r\n   */\n\n\n  static createUploadSession(client, requestUrl, payload, headers = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const session = yield client.api(requestUrl).headers(headers).post(payload);\n        const largeFileUploadSession = {\n          url: session.uploadUrl,\n          expiry: new Date(session.expirationDateTime)\n        };\n        return largeFileUploadSession;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * Parses given range string to the Range instance\r\n   * @param {string[]} ranges - The ranges value\r\n   * @returns The range instance\r\n   */\n\n\n  parseRange(ranges) {\n    const rangeStr = ranges[0];\n\n    if (typeof rangeStr === \"undefined\" || rangeStr === \"\") {\n      return new Range();\n    }\n\n    const firstRange = rangeStr.split(\"-\");\n    const minVal = parseInt(firstRange[0], 10);\n    let maxVal = parseInt(firstRange[1], 10);\n\n    if (Number.isNaN(maxVal)) {\n      maxVal = this.file.size - 1;\n    }\n\n    return new Range(minVal, maxVal);\n  }\n  /**\r\n   * @private\r\n   * Updates the expiration date and the next range\r\n   * @param {UploadStatusResponse} response - The response of the upload status\r\n   * @returns Nothing\r\n   */\n\n\n  updateTaskStatus(response) {\n    this.uploadSession.expiry = new Date(response.expirationDateTime);\n    this.nextRange = this.parseRange(response.nextExpectedRanges);\n  }\n  /**\r\n   * @public\r\n   * Gets next range that needs to be uploaded\r\n   * @returns The range instance\r\n   */\n\n\n  getNextRange() {\n    if (this.nextRange.minValue === -1) {\n      return this.nextRange;\n    }\n\n    const minVal = this.nextRange.minValue;\n    let maxValue = minVal + this.options.rangeSize - 1;\n\n    if (maxValue >= this.file.size) {\n      maxValue = this.file.size - 1;\n    }\n\n    return new Range(minVal, maxValue);\n  }\n  /**\r\n   * @public\r\n   * Slices the file content to the given range\r\n   * @param {Range} range - The range value\r\n   * @returns The sliced ArrayBuffer or Blob\r\n   */\n\n\n  sliceFile(range) {\n    const blob = this.file.content.slice(range.minValue, range.maxValue + 1);\n    return blob;\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Uploads file to the server in a sequential order by slicing the file\r\n   * @returns The promise resolves to uploaded response\r\n   */\n\n\n  upload() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        while (true) {\n          const nextRange = this.getNextRange();\n\n          if (nextRange.maxValue === -1) {\n            const err = new Error(\"Task with which you are trying to upload is already completed, Please check for your uploaded file\");\n            err.name = \"Invalid Session\";\n            throw err;\n          }\n\n          const fileSlice = this.sliceFile(nextRange);\n          const response = yield this.uploadSlice(fileSlice, nextRange, this.file.size); // Upon completion of upload process incase of onedrive, driveItem is returned, which contains id\n\n          if (response.id !== undefined) {\n            return response;\n          } else {\n            this.updateTaskStatus(response);\n          }\n        }\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Uploads given slice to the server\r\n   * @param {ArrayBuffer | Blob | File} fileSlice - The file slice\r\n   * @param {Range} range - The range value\r\n   * @param {number} totalSize - The total size of a complete file\r\n   */\n\n\n  uploadSlice(fileSlice, range, totalSize) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.client.api(this.uploadSession.url).headers({\n          \"Content-Length\": \"\".concat(range.maxValue - range.minValue + 1),\n          \"Content-Range\": \"bytes \".concat(range.minValue, \"-\").concat(range.maxValue, \"/\").concat(totalSize)\n        }).put(fileSlice);\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Deletes upload session in the server\r\n   * @returns The promise resolves to cancelled response\r\n   */\n\n\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.client.api(this.uploadSession.url).delete();\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Gets status for the upload session\r\n   * @returns The promise resolves to the status enquiry response\r\n   */\n\n\n  getStatus() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const response = yield this.client.api(this.uploadSession.url).get();\n        this.updateTaskStatus(response);\n        return response;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Resumes upload session and continue uploading the file from the last sent range\r\n   * @returns The promise resolves to the uploaded response\r\n   */\n\n\n  resume() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.getStatus();\n        return yield this.upload();\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}