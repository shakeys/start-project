{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ResponseType } from \"./ResponseType\";\n/**\r\n * @enum\r\n * Enum for document types\r\n * @property {string} TEXT_HTML - The text/html content type\r\n * @property {string} TEXT_XML - The text/xml content type\r\n * @property {string} APPLICATION_XML - The application/xml content type\r\n * @property {string} APPLICATION_XHTML - The application/xhml+xml content type\r\n */\n\nexport var DocumentType;\n\n(function (DocumentType) {\n  DocumentType[\"TEXT_HTML\"] = \"text/html\";\n  DocumentType[\"TEXT_XML\"] = \"text/xml\";\n  DocumentType[\"APPLICATION_XML\"] = \"application/xml\";\n  DocumentType[\"APPLICATION_XHTML\"] = \"application/xhtml+xml\";\n})(DocumentType || (DocumentType = {}));\n/**\r\n * @enum\r\n * Enum for Content types\r\n * @property {string} TEXT_PLAIN - The text/plain content type\r\n * @property {string} APPLICATION_JSON - The application/json content type\r\n */\n\n\nvar ContentType;\n\n(function (ContentType) {\n  ContentType[\"TEXT_PLAIN\"] = \"text/plain\";\n  ContentType[\"APPLICATION_JSON\"] = \"application/json\";\n})(ContentType || (ContentType = {}));\n/**\r\n * @enum\r\n * Enum for Content type regex\r\n * @property {string} DOCUMENT - The regex to match document content types\r\n * @property {string} IMAGE - The regex to match image content types\r\n */\n\n\nvar ContentTypeRegexStr;\n\n(function (ContentTypeRegexStr) {\n  ContentTypeRegexStr[\"DOCUMENT\"] = \"^(text\\\\/(html|xml))|(application\\\\/(xml|xhtml\\\\+xml))$\";\n  ContentTypeRegexStr[\"IMAGE\"] = \"^image\\\\/.+\";\n})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));\n/**\r\n * @class\r\n * Class for GraphResponseHandler\r\n */\n\n\nexport class GraphResponseHandler {\n  /**\r\n   * @private\r\n   * @static\r\n   * To parse Document response\r\n   * @param {Response} rawResponse - The response object\r\n   * @param {DocumentType} type - The type to which the document needs to be parsed\r\n   * @returns A promise that resolves to a document content\r\n   */\n  static parseDocumentResponse(rawResponse, type) {\n    try {\n      if (typeof DOMParser !== \"undefined\") {\n        return new Promise((resolve, reject) => {\n          rawResponse.text().then(xmlString => {\n            try {\n              const parser = new DOMParser();\n              const xmlDoc = parser.parseFromString(xmlString, type);\n              resolve(xmlDoc);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        });\n      } else {\n        return Promise.resolve(rawResponse.body);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * To convert the native Response to response content\r\n   * @param {Response} rawResponse - The response object\r\n   * @param {ResponseType} [responseType] - The response type value\r\n   * @returns A promise that resolves to the converted response content\r\n   */\n\n\n  static convertResponse(rawResponse, responseType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const clonedRawResponse = rawResponse.clone();\n\n      if (clonedRawResponse.status === 204) {\n        // NO CONTENT\n        return Promise.resolve();\n      }\n\n      let responseValue;\n\n      try {\n        switch (responseType) {\n          case ResponseType.ARRAYBUFFER:\n            responseValue = yield clonedRawResponse.arrayBuffer();\n            break;\n\n          case ResponseType.BLOB:\n            responseValue = yield clonedRawResponse.blob();\n            break;\n\n          case ResponseType.DOCUMENT:\n            responseValue = yield GraphResponseHandler.parseDocumentResponse(clonedRawResponse, DocumentType.TEXT_XML);\n            break;\n\n          case ResponseType.JSON:\n            responseValue = yield clonedRawResponse.json();\n            break;\n\n          case ResponseType.STREAM:\n            responseValue = yield Promise.resolve(clonedRawResponse.body);\n            break;\n\n          case ResponseType.TEXT:\n            responseValue = yield clonedRawResponse.text();\n            break;\n\n          default:\n            const contentType = clonedRawResponse.headers.get(\"Content-type\");\n\n            if (contentType !== null) {\n              const mimeType = contentType.split(\";\")[0];\n\n              if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {\n                responseValue = yield GraphResponseHandler.parseDocumentResponse(clonedRawResponse, mimeType);\n              } else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {\n                responseValue = clonedRawResponse.blob();\n              } else if (mimeType === ContentType.TEXT_PLAIN) {\n                responseValue = yield clonedRawResponse.text();\n              } else if (mimeType === ContentType.APPLICATION_JSON) {\n                responseValue = yield clonedRawResponse.json();\n              } else {\n                responseValue = Promise.resolve(clonedRawResponse.body);\n              }\n            } else {\n              /**\r\n               * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:\r\n               *  A sender that generates a message containing a payload body SHOULD\r\n               *  generate a Content-Type header field in that message unless the\r\n               *  intended media type of the enclosed representation is unknown to the\r\n               *  sender.  If a Content-Type header field is not present, the recipient\r\n               *  MAY either assume a media type of \"application/octet-stream\"\r\n               *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.\r\n               *\r\n               *  So assuming it as a stream type so returning the body.\r\n               */\n              responseValue = Promise.resolve(clonedRawResponse.body);\n            }\n\n            break;\n        }\n      } catch (error) {\n        throw error;\n      }\n\n      return responseValue;\n    });\n  }\n  /**\r\n   * @public\r\n   * @static\r\n   * @async\r\n   * To get the parsed response\r\n   * @param {Response} rawResponse - The response object\r\n   * @param {ResponseType} [responseType] - The response type value\r\n   * @param {GraphRequestCallback} [callback] - The graph request callback function\r\n   * @returns The parsed response\r\n   */\n\n\n  static getResponse(rawResponse, responseType, callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (responseType === ResponseType.RAW) {\n          return Promise.resolve(rawResponse);\n        } else {\n          const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);\n\n          if (rawResponse.ok) {\n            // Status Code 2XX\n            if (typeof callback === \"function\") {\n              callback(null, response, rawResponse);\n            } else {\n              return response;\n            }\n          } else {\n            // NOT OK Response\n            throw response;\n          }\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}