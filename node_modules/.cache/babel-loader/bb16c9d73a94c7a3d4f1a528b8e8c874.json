{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/**\r\n * @module BatchRequestContent\r\n */\n\n\nimport { RequestMethod } from \"../RequestMethod\";\n/**\r\n * @class\r\n * Class for handling BatchRequestContent\r\n */\n\nexport class BatchRequestContent {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * Constructs a BatchRequestContent instance\r\n   * @param {BatchRequestStep[]} [requests] - Array of requests value\r\n   * @returns An instance of a BatchRequestContent\r\n   */\n  constructor(requests) {\n    this.requests = new Map();\n\n    if (typeof requests !== \"undefined\") {\n      const limit = BatchRequestContent.requestLimit;\n\n      if (requests.length > limit) {\n        const error = new Error(\"Maximum requests limit exceeded, Max allowed number of requests are \".concat(limit));\n        error.name = \"Limit Exceeded Error\";\n        throw error;\n      }\n\n      for (const req of requests) {\n        this.addRequest(req);\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * Validates the dependency chain of the requests\r\n   *\r\n   * Note:\r\n   * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:\r\n   * 1. Parallel - no individual request states a dependency in the dependsOn property.\r\n   * 2. Serial - all individual requests depend on the previous individual request.\r\n   * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\r\n   * As JSON batching matures, these limitations will be removed.\r\n   * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n   *\r\n   * @param {Map<string, BatchRequestStep>} requests - The map of requests.\r\n   * @returns The boolean indicating the validation status\r\n   */\n\n\n  static validateDependencies(requests) {\n    const isParallel = reqs => {\n      const iterator = reqs.entries();\n      let cur = iterator.next();\n\n      while (!cur.done) {\n        const curReq = cur.value[1];\n\n        if (curReq.dependsOn !== undefined && curReq.dependsOn.length > 0) {\n          return false;\n        }\n\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    const isSerial = reqs => {\n      const iterator = reqs.entries();\n      let cur = iterator.next();\n      const firstRequest = cur.value[1];\n\n      if (firstRequest.dependsOn !== undefined && firstRequest.dependsOn.length > 0) {\n        return false;\n      }\n\n      let prev = cur;\n      cur = iterator.next();\n\n      while (!cur.done) {\n        const curReq = cur.value[1];\n\n        if (curReq.dependsOn === undefined || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {\n          return false;\n        }\n\n        prev = cur;\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    const isSame = reqs => {\n      const iterator = reqs.entries();\n      let cur = iterator.next();\n      const firstRequest = cur.value[1];\n      let dependencyId;\n\n      if (firstRequest.dependsOn === undefined || firstRequest.dependsOn.length === 0) {\n        dependencyId = firstRequest.id;\n      } else {\n        if (firstRequest.dependsOn.length === 1) {\n          const fDependencyId = firstRequest.dependsOn[0];\n\n          if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {\n            dependencyId = fDependencyId;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      cur = iterator.next();\n\n      while (!cur.done) {\n        const curReq = cur.value[1];\n\n        if ((curReq.dependsOn === undefined || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {\n          return false;\n        }\n\n        if (curReq.dependsOn !== undefined && curReq.dependsOn.length !== 0) {\n          if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {\n            return false;\n          }\n\n          if (curReq.dependsOn.length > 1) {\n            return false;\n          }\n        }\n\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    if (requests.size === 0) {\n      const error = new Error(\"Empty requests map, Please provide at least one request.\");\n      error.name = \"Empty Requests Error\";\n      throw error;\n    }\n\n    return isParallel(requests) || isSerial(requests) || isSame(requests);\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * Converts Request Object instance to a JSON\r\n   * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance\r\n   * @returns A promise that resolves to JSON representation of a request\r\n   */\n\n\n  static getRequestData(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const requestData = {\n        url: \"\"\n      };\n      const hasHttpRegex = new RegExp(\"^https?://\"); // Stripping off hostname, port and url scheme\n\n      requestData.url = hasHttpRegex.test(request.url) ? \"/\" + request.url.split(/.*?\\/\\/.*?\\//)[1] : request.url;\n      requestData.method = request.method;\n      const headers = {};\n      request.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      if (Object.keys(headers).length) {\n        requestData.headers = headers;\n      }\n\n      if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {\n        requestData.body = yield BatchRequestContent.getRequestBody(request);\n      }\n      /**\r\n       * TODO: Check any other property needs to be used from the Request object and add them\r\n       */\n\n\n      return requestData;\n    });\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * Gets the body of a Request object instance\r\n   * @param {IsomorphicRequest} request - The IsomorphicRequest object instance\r\n   * @returns The Promise that resolves to a body value of a Request\r\n   */\n\n\n  static getRequestBody(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let bodyParsed = false;\n      let body;\n\n      try {\n        const cloneReq = request.clone();\n        body = yield cloneReq.json();\n        bodyParsed = true;\n      } catch (e) {// tslint:disable-line: no-empty\n      }\n\n      if (!bodyParsed) {\n        try {\n          if (typeof Blob !== \"undefined\") {\n            const blob = yield request.blob();\n            const reader = new FileReader();\n            body = yield new Promise(resolve => {\n              reader.addEventListener(\"load\", () => {\n                const dataURL = reader.result;\n                /**\r\n                 * Some valid dataURL schemes:\r\n                 *  1. data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh\r\n                 *  2. data:text/plain;charset=UTF-8;page=21,the%20data:1234,5678\r\n                 *  3. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 *  4. data:image/png,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 *  5. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 * @see Syntax {@link https://en.wikipedia.org/wiki/Data_URI_scheme} for more\r\n                 */\n\n                const regex = new RegExp(\"^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$\");\n                const segments = regex.exec(dataURL);\n                resolve(segments[4]);\n              }, false);\n              reader.readAsDataURL(blob);\n            });\n          } else if (typeof Buffer !== \"undefined\") {\n            const buffer = yield request.buffer();\n            body = buffer.toString(\"base64\");\n          }\n\n          bodyParsed = true;\n        } catch (e) {// tslint:disable-line: no-empty\n        }\n      }\n\n      return body;\n    });\n  }\n  /**\r\n   * @public\r\n   * Adds a request to the batch request content\r\n   * @param {BatchRequestStep} request - The request value\r\n   * @returns The id of the added request\r\n   */\n\n\n  addRequest(request) {\n    const limit = BatchRequestContent.requestLimit;\n\n    if (request.id === \"\") {\n      const error = new Error(\"Id for a request is empty, Please provide an unique id\");\n      error.name = \"Empty Id For Request\";\n      throw error;\n    }\n\n    if (this.requests.size === limit) {\n      const error = new Error(\"Maximum requests limit exceeded, Max allowed number of requests are \".concat(limit));\n      error.name = \"Limit Exceeded Error\";\n      throw error;\n    }\n\n    if (this.requests.has(request.id)) {\n      const error = new Error(\"Adding request with duplicate id \".concat(request.id, \", Make the id of the requests unique\"));\n      error.name = \"Duplicate RequestId Error\";\n      throw error;\n    }\n\n    this.requests.set(request.id, request);\n    return request.id;\n  }\n  /**\r\n   * @public\r\n   * Removes request from the batch payload and its dependencies from all dependents\r\n   * @param {string} requestId - The id of a request that needs to be removed\r\n   * @returns The boolean indicating removed status\r\n   */\n\n\n  removeRequest(requestId) {\n    const deleteStatus = this.requests.delete(requestId);\n    const iterator = this.requests.entries();\n    let cur = iterator.next();\n    /**\r\n     * Removing dependencies where this request is present as a dependency\r\n     */\n\n    while (!cur.done) {\n      const dependencies = cur.value[1].dependsOn;\n\n      if (typeof dependencies !== \"undefined\") {\n        const index = dependencies.indexOf(requestId);\n\n        if (index !== -1) {\n          dependencies.splice(index, 1);\n        }\n\n        if (dependencies.length === 0) {\n          delete cur.value[1].dependsOn;\n        }\n      }\n\n      cur = iterator.next();\n    }\n\n    return deleteStatus;\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Serialize content from BatchRequestContent instance\r\n   * @returns The body content to make batch request\r\n   */\n\n\n  getContent() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const requests = [];\n      const requestBody = {\n        requests\n      };\n      const iterator = this.requests.entries();\n      let cur = iterator.next();\n\n      if (cur.done) {\n        const error = new Error(\"No requests added yet, Please add at least one request.\");\n        error.name = \"Empty Payload\";\n        throw error;\n      }\n\n      if (!BatchRequestContent.validateDependencies(this.requests)) {\n        const error = new Error(\"Invalid dependency found, Dependency should be:\\n1. Parallel - no individual request states a dependency in the dependsOn property.\\n2. Serial - all individual requests depend on the previous individual request.\\n3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\");\n        error.name = \"Invalid Dependency\";\n        throw error;\n      }\n\n      while (!cur.done) {\n        const requestStep = cur.value[1];\n        const batchRequestData = yield BatchRequestContent.getRequestData(requestStep.request);\n        /**\r\n         * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/json_batching#request-format}\r\n         */\n\n        if (batchRequestData.body !== undefined && (batchRequestData.headers === undefined || batchRequestData.headers[\"content-type\"] === undefined)) {\n          const error = new Error(\"Content-type header is not mentioned for request #\".concat(requestStep.id, \", For request having body, Content-type header should be mentioned\"));\n          error.name = \"Invalid Content-type header\";\n          throw error;\n        }\n\n        batchRequestData.id = requestStep.id;\n\n        if (requestStep.dependsOn !== undefined && requestStep.dependsOn.length > 0) {\n          batchRequestData.dependsOn = requestStep.dependsOn;\n        }\n\n        requests.push(batchRequestData);\n        cur = iterator.next();\n      }\n\n      requestBody.requests = requests;\n      return requestBody;\n    });\n  }\n  /**\r\n   * @public\r\n   * Adds a dependency for a given dependent request\r\n   * @param {string} dependentId - The id of the dependent request\r\n   * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency\r\n   * @returns Nothing\r\n   */\n\n\n  addDependency(dependentId, dependencyId) {\n    if (!this.requests.has(dependentId)) {\n      const error = new Error(\"Dependent \".concat(dependentId, \" does not exists, Please check the id\"));\n      error.name = \"Invalid Dependent\";\n      throw error;\n    }\n\n    if (typeof dependencyId !== \"undefined\" && !this.requests.has(dependencyId)) {\n      const error = new Error(\"Dependency \".concat(dependencyId, \" does not exists, Please check the id\"));\n      error.name = \"Invalid Dependency\";\n      throw error;\n    }\n\n    if (typeof dependencyId !== \"undefined\") {\n      const dependent = this.requests.get(dependentId);\n\n      if (dependent.dependsOn === undefined) {\n        dependent.dependsOn = [];\n      }\n\n      if (dependent.dependsOn.indexOf(dependencyId) !== -1) {\n        const error = new Error(\"Dependency \".concat(dependencyId, \" is already added for the request \").concat(dependentId));\n        error.name = \"Duplicate Dependency\";\n        throw error;\n      }\n\n      dependent.dependsOn.push(dependencyId);\n    } else {\n      const iterator = this.requests.entries();\n      let prev;\n      let cur = iterator.next();\n\n      while (!cur.done && cur.value[1].id !== dependentId) {\n        prev = cur;\n        cur = iterator.next();\n      }\n\n      if (typeof prev !== \"undefined\") {\n        const dId = prev.value[0];\n\n        if (cur.value[1].dependsOn === undefined) {\n          cur.value[1].dependsOn = [];\n        }\n\n        if (cur.value[1].dependsOn.indexOf(dId) !== -1) {\n          const error = new Error(\"Dependency \".concat(dId, \" is already added for the request \").concat(dependentId));\n          error.name = \"Duplicate Dependency\";\n          throw error;\n        }\n\n        cur.value[1].dependsOn.push(dId);\n      } else {\n        const error = new Error(\"Can't add dependency \".concat(dependencyId, \", There is only a dependent request in the batch\"));\n        error.name = \"Invalid Dependency Addition\";\n        throw error;\n      }\n    }\n  }\n  /**\r\n   * @public\r\n   * Removes a dependency for a given dependent request id\r\n   * @param {string} dependentId - The id of the dependent request\r\n   * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request\r\n   * @returns The boolean indicating removed status\r\n   */\n\n\n  removeDependency(dependentId, dependencyId) {\n    const request = this.requests.get(dependentId);\n\n    if (typeof request === \"undefined\" || request.dependsOn === undefined || request.dependsOn.length === 0) {\n      return false;\n    }\n\n    if (typeof dependencyId !== \"undefined\") {\n      const index = request.dependsOn.indexOf(dependencyId);\n\n      if (index === -1) {\n        return false;\n      }\n\n      request.dependsOn.splice(index, 1);\n      return true;\n    } else {\n      delete request.dependsOn;\n      return true;\n    }\n  }\n\n}\n/**\r\n * @private\r\n * @static\r\n * Limit for number of requests {@link - https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n */\n\nBatchRequestContent.requestLimit = 20;","map":null,"metadata":{},"sourceType":"module"}