{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\r\n * @hidden\r\n */\nimport { AadAuthority } from \"./AadAuthority\";\nimport { B2cAuthority } from \"./B2cAuthority\";\nimport { AuthorityType } from \"./Authority\";\nimport { ClientConfigurationErrorMessage } from \"./error/ClientConfigurationError\";\nimport { UrlUtils } from \"./utils/UrlUtils\";\nimport { StringUtils } from \"./utils/StringUtils\";\n\nvar AuthorityFactory =\n/** @class */\nfunction () {\n  function AuthorityFactory() {}\n  /**\r\n  * Parse the url and determine the type of authority\r\n  */\n\n\n  AuthorityFactory.DetectAuthorityFromUrl = function (authorityUrl) {\n    authorityUrl = UrlUtils.CanonicalizeUri(authorityUrl);\n    var components = UrlUtils.GetUrlComponents(authorityUrl);\n    var pathSegments = components.PathSegments;\n\n    switch (pathSegments[0]) {\n      case \"tfp\":\n        return AuthorityType.B2C;\n\n      case \"adfs\":\n        return AuthorityType.Adfs;\n\n      default:\n        return AuthorityType.Aad;\n    }\n  };\n  /**\r\n  * Create an authority object of the correct type based on the url\r\n  * Performs basic authority validation - checks to see if the authority is of a valid type (eg aad, b2c)\r\n  */\n\n\n  AuthorityFactory.CreateInstance = function (authorityUrl, validateAuthority) {\n    if (StringUtils.isEmpty(authorityUrl)) {\n      return null;\n    }\n\n    var type = AuthorityFactory.DetectAuthorityFromUrl(authorityUrl); // Depending on above detection, create the right type.\n\n    switch (type) {\n      case AuthorityType.B2C:\n        return new B2cAuthority(authorityUrl, validateAuthority);\n\n      case AuthorityType.Aad:\n        return new AadAuthority(authorityUrl, validateAuthority);\n\n      default:\n        throw ClientConfigurationErrorMessage.invalidAuthorityType;\n    }\n  };\n\n  return AuthorityFactory;\n}();\n\nexport { AuthorityFactory };","map":null,"metadata":{},"sourceType":"module"}