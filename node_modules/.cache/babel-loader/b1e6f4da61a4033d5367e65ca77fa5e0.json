{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/**\r\n * @constant\r\n * To generate the UUID\r\n * @returns The UUID string\r\n */\n\n\nexport const generateUUID = () => {\n  let uuid = \"\";\n\n  for (let j = 0; j < 32; j++) {\n    if (j === 8 || j === 12 || j === 16 || j === 20) {\n      uuid += \"-\";\n    }\n\n    uuid += Math.floor(Math.random() * 16).toString(16);\n  }\n\n  return uuid;\n};\n/**\r\n * @constant\r\n * To get the request header from the request\r\n * @param {RequestInfo} request - The request object or the url string\r\n * @param {FetchOptions|undefined} options - The request options object\r\n * @param {string} key - The header key string\r\n * @returns A header value for the given key from the request\r\n */\n\nexport const getRequestHeader = (request, options, key) => {\n  let value = null;\n\n  if (request instanceof Request) {\n    value = request.headers.get(key);\n  } else if (typeof options !== \"undefined\" && options.headers !== undefined) {\n    if (options.headers instanceof Headers) {\n      value = options.headers.get(key);\n    } else if (options.headers instanceof Array) {\n      const headers = options.headers;\n\n      for (let i = 0, l = headers.length; i < l; i++) {\n        if (headers[i][0] === key) {\n          value = headers[i][1];\n          break;\n        }\n      }\n    } else if (options.headers[key] !== undefined) {\n      value = options.headers[key];\n    }\n  }\n\n  return value;\n};\n/**\r\n * @constant\r\n * To set the header value to the given request\r\n * @param {RequestInfo} request - The request object or the url string\r\n * @param {FetchOptions|undefined} options - The request options object\r\n * @param {string} key - The header key string\r\n * @param {string } value - The header value string\r\n * @returns Nothing\r\n */\n\nexport const setRequestHeader = (request, options, key, value) => {\n  if (request instanceof Request) {\n    request.headers.set(key, value);\n  } else if (typeof options !== \"undefined\") {\n    if (options.headers === undefined) {\n      options.headers = {\n        [key]: value\n      };\n    } else {\n      if (options.headers instanceof Headers) {\n        options.headers.set(key, value);\n      } else if (options.headers instanceof Array) {\n        options.headers.push([key, value]);\n      } else {\n        Object.assign(options.headers, {\n          [key]: value\n        });\n      }\n    }\n  }\n};\n/**\r\n * @constant\r\n * To clone the request with the new url\r\n * @param {string} url - The new url string\r\n * @param {Request} request - The request object\r\n * @returns A promise that resolves to request object\r\n */\n\nexport const cloneRequestWithNewUrl = (newUrl, request) => __awaiter(this, void 0, void 0, function* () {\n  const body = request.headers.get(\"Content-Type\") ? yield request.blob() : yield Promise.resolve(undefined);\n  const method = request.method,\n        headers = request.headers,\n        referrer = request.referrer,\n        referrerPolicy = request.referrerPolicy,\n        mode = request.mode,\n        credentials = request.credentials,\n        cache = request.cache,\n        redirect = request.redirect,\n        integrity = request.integrity,\n        keepalive = request.keepalive,\n        signal = request.signal;\n  return new Request(newUrl, {\n    method,\n    headers,\n    body,\n    referrer,\n    referrerPolicy,\n    mode,\n    credentials,\n    cache,\n    redirect,\n    integrity,\n    keepalive,\n    signal\n  });\n});","map":null,"metadata":{},"sourceType":"module"}